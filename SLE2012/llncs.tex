% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{llncsdoc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{bold-extra}
%



\begin{document}
\lstset{ 
	language = [AspectJ]Java,
  basicstyle=\ttfamily\footnotesize,
  numbers=left,
	numberstyle=\tiny\color[rgb]{0.25,0.25,0.25},
  firstnumber=auto,
	breaklines=true,
  tabsize=2,
	emph={aspect,declare, adapter, instance, pointcut, adaptee, adapts}, 
	emphstyle=\textbf,
	frame=single
	}

\title{SLE2012}

\author{Kardelen Hatun \and Christoph Bockisch \and Mehmet Ak\c{s}it}
\institute{TRESE, University of Twente \\ 7500AE Enschede \\ The Netherlands \\
\url{http://www.utwente.nl/ewi/trese/}\\
\email{ \{hatunk,c.m.bockisch,aksit\}@ewi.utwente.nl}
}

\maketitle
\section{Introduction}

Components interact through their interfaces. In component-based systems, there are cases where a certain functionality is provided by a third-party software which usually comes with an incompatible interface, which makes connecting new components and the existing components a challenge.  An important requirement of \emph{binding} two components is to encapsulate the binding declarations in a separate module, while leaving the bound components untouched.  In this study we present a language which satisfies this requirement and offers a reusable, maintainable and concise way of expressing binding.

Our language is composed of two main structures; \textbf{instance pointcuts} and \textbf{adapter declarations}. Instance pointcuts are specialized pointcuts, which are used to capture the instances of a type, which at some point in their life cycle become relevant. This can be creation of the instance, calling a certain method on the instance or passing the instance as an argument. The conditions for becoming relevant is defined in the pointcut expression. Adapter declarations provide a declarative syntax for implementing object adapters, where the objects to be adapted are selected by instance pointcuts. The benefit of our approach partly comes from utilization of Aspect Orientation (AO), which allows modularization of binding concern. But the major benefit is due to the marriage of two new language concepts which take object adapters to a new level. 

The traditional object adapter is shown in Figure \textsl{(objectadapter)}. Instance pointcuts provide means to select a subset of instances that belong to a specific type. It is also possible to select all subtype instances of a supertype, since the instance pointcut captures dynamic types. In adapter declarations this subset can be adapted by referring to the instance pointcut. An adapter declaration consists of a unique name, an instance pointcut reference and a list of interfaces to be implemented. The interface methods are overriden in the adapter declaration, referring to its \emph{adaptee} where adaptee is an instance belonging to the set of instances selected by the instance pointcut. When an instance pointcut expression matches a join-point and that instance pointcut is referred to by an adapter declaration, then an adapter instance is automatically created containing the instance in the matched join-point.  In an OO approach this would require adapter instantiations at various points in the code, which will cause tangling of adapter instantiation concern. 

It is also possible to have an inheritance hierarchy among adapters, by defining \emph{abstract adapters}. Abstract adapters do not have to implement all the interfaces they declare, whereas \emph{concrete adapters} have to provide an implementation for every interface they declare or for the unimplemented interface declared by their super-adapter. Concrete adapters can also override the implementations of their super-adapters. This abstraction mechanisms leads to maintainable adapters and reduce programming efforts should the components evolve.

The AO nature of our approach allows all of these features to be encapsulated in an aspect. The concern is localized therefore there's no scattering and tangling. Moreover a run-time library for querying and retrieving adapters is created. With this library the user can query adapters by using an instance, a type, an adapter name or a combination of these as a key. This allows accessing adapters in a flexible way, whereas in the traditional OO implementation, it is only possible to access an adapter is by using its instance name.  


\section{The Binding Language}

Instance pointcuts and adapter declarations are language concepts and ideally every aspect-oriented language can be extended to host them. We have implemented a prototype in AspectJ. While we have extended the syntax of AspectJ for instance pointcuts and adapter declarations, we have reused AspectJ's join-point model in instance pointcut expressions.  We will discuss possible extensions in other well known AO-languages at the end of this section. 

\begin{figure}
\centering

\subfigure[Shapes Hierarchy]{
   \includegraphics[width=0.4\textwidth] {images/shapes.png}
   \label{fig:shapes}
 }~~~
 \subfigure[ShapeInfo and used interfaces]{
   \includegraphics[width=0.5\textwidth] {images/shapeint.png}
   \label{fig:shapesi}
 }

\label{fig:example1}
\caption{Shapes Example}
\end{figure}

%\subsection{Basic Language Features}
We will explain the basics of the language with the help of a simple example. In Figure \ref{fig:shapes} a simple hierarchy of shapes is shown. The abstract class \texttt{Shape} has two subtypes called \texttt{Circle} and \texttt{Rectangle}. The interfaces provided by these classes can be seen in the figure. The \texttt{ShapeInfo} class shown in Figure \ref{fig:shapesi} collects the area and the circumference information of a given \texttt{Shape} using \texttt{ShapeArea} and \texttt{ShapeCircumference} interfaces, which are not implemented by any of the classes in the \texttt{Shape} hierarchy. 

In Listing \ref{lst:circle} an simple instance pointcut that selects \texttt{Circle} instances and an adapter using that pointcut is defined. The name of the instance pointcut (line 2) is \textbf{\texttt{circles}} and the instance type is shown in Java generics syntax as \texttt{\textbf{<Circle>}}. The \texttt{call} primitive pointcut selects the join points where a new \texttt{Circle} object is created,then \texttt{\textbf{returning(instance)}} binds the returned \texttt{Circle} instance to the \emph{implicit variable} \texttt{\textbf{instance}}. The complete set of features of instance pointcuts will be discussed in Section \ref{sec:ip}. The adapter declaration (line 4), defines an adapter called \texttt{CircleAdapter} which implements \texttt{ShapeArea} and \texttt{ShapeCircumference} interfaces, indicated inside the curly braces. After the \texttt{\textbf{adapts}} keyword we declare which set of object we would like to adapt, in this case the set of objects selected by the \texttt{circles} pointcut. In the body of an adapter declaration, the implementation of the declared interfaces is given. Notice the \texttt{\textbf{adaptee}} keyword in the method bodies (lines 7, 12). The \texttt{adaptee} keyword refers to the object that's being adapted, in this case a \texttt{Circle} object, therefore can access its methods. 

\begin{lstlisting}[float=tb, caption={An instance pointcut selecting Circle objects and an adapter declaration using this pointcut}, label={lst:circle}]
aspect ShapeAdapterAspect{
	instance pointcut circles<Circle> : call(* Circle.new(..)) && returning(instance);

	declare adapter: CircleAdapter{ShapeArea, ShapeCircumference} adapts circles{
		public double getArea()
		{
			return Math.PI*adaptee.getRadius()*adaptee.getRadius();
		}
				
		public double getCircumference()
		{
			return 2*Math.PI*adaptee.getRadius();
		}
	}
}
\end{lstlisting}

\subsection{Instance Pointcuts}
\label{sec:ip}
Instance pointcut is a declarative language construct to select a subset of objects of a specific type. Although throughout the paper we use instance pointcuts with adapters, they can be used on their own and they are decorated with handy features to make object selection and manipulation easier.

A concrete instance pointcut definition consists of a left hand-side and a right-hand side. In the left hand side the pointcut's name and the instance type of interest is declared. In the left hand side a pointcut expression which describes the desired join-points is composed with a \emph{single} content exposure pointcut to bind the exposed instance to the \emph{implicit variable} called \textbf{instance}. It is also possible to declare an abstract instance pointcut, exactly the same way one would define a normal abstract pointcut. 

\vspace{-15}
\begin{lstlisting}[float=h!]
instance pointcut pc<Shape>: call(* Shape+.new(..)) && within(ShapeGenerator1);
\end{lstlisting}



\subsection{Adapters}

\subsection{Adapter Hierarchies}
In this section we will add a new required interface to the example presented in Figure \ref{fig:example1}, called \texttt{ShapeColor}. This interface has a \texttt{getColor()} method, which returns \texttt{RED} if the area of the shape is smaller than \texttt{40} and \texttt{BLUE} for the rest. 

\begin{lstlisting}[float=tb, caption={An Adapter Hierarchy}, label={lst:adaphier}]
aspect ShapeAdapterAspect{
	instance pointcut shapes<Shape> : call(* Shape+.new(..)) && returning(instance);
	
	declare adapter: abstract ShapeAdapter{ShapeArea, ShapeCircumference, ShapeArea} adapts shapes{
		public String getColor(){
			if(this.getArea() < 40)
				return ``RED'';
			else
				return ``BLUE'';
		}
	}

	declare adapter: CircleAdapter extends ShapeAdapter adapts shapes<Circle>{
		//Implementation of ShapeArea and ShapeCircumference
	}
	declare adapter: RectangleAdapter extends ShapeAdapter adapts shapes<Rectangle>{
		//Implementation of ShapeArea and ShapeCircumference
	}
}
\end{lstlisting}

In Listing \ref{lst:adaphier} an adapter hierarchy is shown. We have modified the instance pointcut to capture all \texttt{Shape} instances including instances of its subtypes using the ``+'' operator of AspectJ(line 2). The implementation of the \texttt{ShapeColor} interface does not depend on the instance type. We provide the implementation of this interface in an \textbf{abstract adapter} called \texttt{ShapeAdapter}(line 4) , which adapts all the \texttt{Shape} objects that are created. An adapter is declared abstract by placing the \texttt{abstract} modifier before its name. \emph{An abstract adapter can have unimplemented methods, whereas a concrete adapter had to implement all the unimplemented interface methods it declares and inherits.} Since \texttt{ShapeAdapter} is abstract it does not have to implement \texttt{ShapeArea} and \texttt{ShapeCircumference}, however it can refer to these interfaces' methods, as seen in line 6.  Abstract adapters cannot be instantiated, therefore it is necessary to have sub-adapters that are concrete.

The concrete adapters extending \texttt{ShapeAdapter} are \texttt{CircleAdapter} (line 13) and \texttt{RectangleAdapter} (line 16). There are two things to notice in these sub-adapter declarations. First is that they do not declare any interfaces, that information is inherited from \texttt{ShapeAdapter} declaration. The second is the way instance pointcut \texttt{shapes} is refined. \emph{Instance pointcuts store the dynamic types of instances.} The statement \texttt{\textbf{shapes<Circle>}} selects a subset of \texttt{Shape} objects which have the dynamic type \texttt{Circle}. This refinement mechanism lets us create a \texttt{CircleAdapter} without writing a new pointcut which explicitly selects \texttt{Circle} instances, also by refining the same pointcut used in the super-adapter we ensure the set of \texttt{Circle} objects are a subset of \texttt{Shape} objects selected by \texttt{shapes} instance pointcut.

\textbf{\textcolor[rgb]{1,0,0}{I think we should discuss whether we allow using a different pointcut in the sub-adapters.}}

\subsection{Adapter Instantiation and Retrieval}
While adapters are widely used to resolve incompatible interface problem, they introduce a cross-cutting concern to the which we identify as \emph{adapter instantiation concern}. In an OO-approach  the \texttt{ShapeInfo}(Figure \ref{fig:shapesi}) class has to create or reuse a \texttt{CircleAdapter} whenever it wants to get the area of a \texttt{Circle} object. In such a small example this does not cause a hindrance. However if we increase the size of this problem into a thousand \texttt{Shape} instances and increase the number of interfaces ShapeInfo has to deal with to 20, then instantiation of the right adapters for the right shapes and managing these adapters is not so trivial anymore. 

Instance pointcuts and adapters declarations provide a declarative way for matching instances with the appropriate adapters. When an instance pointcut matches an instance and there's a concrete adapter declaration for that instance pointcut, the adapter instance containing the matching instance is automatically created. The automatic creation of adapters is an implicit behavior and it modularizes the adapter instantiation concern. 


\section{Related Work}


\end{document}


%Software evolution requires integration of new components with the old ones. In an
%ideal component-based system, this integration should be seamless meaning 
 %the legacy components remain untouched and the interface of the new component is fully compatible with the existing interfaces. 
%Unfortunately such systems do not exist; as a result the integration is seldom
%seamless. Throughout the paper we will refer to the integration of two software components as a
%\emph{binding}. 
%
%We have defined three major challenges regarding binding. 
%\begin{enumerate}
  	%\item When components evolve, the links between them
	%must be re-established. 
 	 %\item When adding unforeseen functionality to a system, no explicit hooks
 	 %exist for attaching the new component. 
	%\item The interface of the components is not compatible and they should be adapted.
%\end{enumerate}
%
%Handling the first challenge requires a \emph{maintainable} way of expressing binding. It is possible to program binding according to some foreseeable evolution scenarios. However in today's component-based systems, third-party software is widely used. So when the interface offered by a third-party software changes, it is necessary to re-program the binding. \emph{Reusable binding structures} and expressing binding in a \emph{concise} manner is then valuable to reduce this programming effort.
%
%Handling the second challenge requires a means to expose certain information in an
%application's control flow and inject additional behavior to the control flow. Context exposure can be done via object-oriented programming(OOP), by providing classes which store and expose context information. Injecting additional behavior can be achieved via design patterns like dependency injection or decorator. However these methods are valid for planned extensions, and they will not be sufficient when a new component needs to access an unexposed context. Another issue is linked to the nature of binding two components. Since components need to be connected through possibly multiple points the \textbf{binding concern} becomes cross-cutting. It has been shown that OOP is not effective in modularizing such cross-cutting concerns.  
%
%Handling the third challenge requires a means to express the mapping between components. In this paper we present new language mechanisms to express such mappings and provide improvement on the solutions of the first two challenges. Our approach consists of two language concepts that work together; \emph{instance selectors} and \emph{adapter declarations}. 
%
%In the original GoF book, Adapter Pattern's purpose is defined as ``converting the interface of a class into another interface clients expect. Adapter lets classes work together that could not otherwise because of incompatible interfaces''. Adapters are an important part of a component-based system, since they are the building blocks of binding. 
%
%Our approach is designed as an addition to Aspect-Oriented Programming (AOP)\textbf{(?)}. AOP is used to modularize crosscutting
%concerns and with its 'weaving' mechanism, it is possible to change the behavior or the structure of an implementation without altering the
%implementation itself. These properties of AOP make it a desirable candidate for modularizing the binding concern.
%
%AOP is effective for achieving loose-coupling. It
%can capture information or inject behavior from a component without being
%acknowledged. AOP also facilitates the OO way of loose-coupling, which done via
%interfaces. It is possible to declare subtypes of an interface and provide the
%subsequent implementation in an aspect.  AOP is also efficient in localizing a concern. So when two components are bound using
%AOP, the binding implementation will be in one place. This is an important
%property for maintaining the modules providing loose-coupling. 
%
%\textcolor[rgb]{0.50,0.50,0.50}{A pointcut is a program construct that selects join points and expose context at
%those points \textbf{(AspectJ in Action book)}. Hence by using pointcuts we can
%define entry points to a system to inject new behavior. Of course this approach
%is limited with the expressiveness of the join-point model of the AO-language. }
%
%However implementation of adapters in current AOP approaches is type invasive. In AspectJ Adapter Pattern is implemented via inter-type declarations which alter the type system by making the adaptee implement a certain interface. This changes the type hierarchy of the adaptee. Also the Adapter Pattern disappears into the AspectJ syntax, which diminishes the visibility of the pattern. CaesarJ has an explicit syntax for defining adapters, which are referred to as wrappers in CaesarJ. However CeaserJ, although it gives great power over separation of concerns, tend to become too fragmented, hurting maintainability. 
