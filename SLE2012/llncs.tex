% This is LLNCS.DOC the documentation file of
% the LaTeX2e class from Springer-Verlag
% for Lecture Notes in Computer Science, version 2.4
\documentclass{llncs}
\usepackage{llncsdoc}
\usepackage{color}
%
\begin{document}

\title{SLE2012}

\author{Kardelen Hatun \and Christoph Bockisch \and Mehmet Ak\c{s}it}
\institute{TRESE, University of Twente \\ 7500AE Enschede \\ The Netherlands \\
\url{http://www.utwente.nl/ewi/trese/}\\
\email{ \{hatunk,c.m.bockisch,aksit\}@ewi.utwente.nl}
}

\maketitle
\section{Introduction}

Component interact through their interfaces. In component-based systems, there are cases where a certain functionality is provided by a third-party software which usually comes with an incompatible interface, which makes connecting new components and the legacy components a challenge. For example the legacy component has a private variable for which it does not provide setters and getters. Then accesing this variable requires either making it public or modifying the legacy interface to offer setters and getters for it. Such changes may cause undesired effects on the system, like a security violation due to changed visibility. So an important requirement of \emph{binding} two components is to encapsulate the binding declarations in a separate module, while leaving the bound components untouched. In this study we present a language which satisfies this requirement and offers a reusable, maintainable and concise way of expressing binding.

Our language is composed of two main structures; \textbf{instance pointcuts} and \textbf{adapter declarations}. Instance pointcuts are specialized pointcuts, which are used to capture the instances of a type, which at some point in their life cycle become relevant. This can be creation of the instance, calling a certain method on the instance or passing the instance as an argument. The conditions for becoming relevant is defined in the pointcut expression. Adapter declarations provide a declarative syntax for implementing object adapters, where the objects to be adapted are selected by instance pointcuts. The benefit of our approach partly comes from utilization of Aspect Orientation (AO), which allows modularization of binding concern. But the major benefit is due to the marriage of two new language concepts which take object adapters to a new level. 

The traditional object adapter is shown in Figure \textsl{(objectadapter)}. Instance pointcuts provide means to select a subset of instances that belong to a specific type. It is also possible to select all subtype instances of a supertype, since the instance pointcut captures dynamic types. In adapter declarations this subset can be adapted by referring to the instance pointcut. An adapter declaration consists of a unique name, an instance pointcut reference and a list of interfaces to be implemented. The interface methods are overriden in the adapter declaration, referring to its \emph{adaptee} where adaptee is an instance belonging to the set of instances selected by the instance pointcut. When an instance pointcut expression matches a join-point and that instance pointcut is referred to by an adapter declaration, then an adapter instance is automatically created containing the instance in the matched join-point.  In an OO approach this would require adapter instantiations at various points in the code, which will cause tangling of adapter instantiation concern. 

It is also possible to have an inheritance hierarchy among adapters, by defining \emph{abstract adapters}. Abstract adapters do not have to implement all the interfaces they declare, whereas \emph{concrete adapters} have to provide an implementation for every interface they declare or for the unimplemented interface declared by their super-adapter. Concrete adapters can also override the implementations of their super-adapters. This abstraction mechanisms leads to maintainable adapters and reduce programming efforts should the components evolve.

The AO nature of our approach allows all of these features to be encapsulated in an aspect. The concern is localized therefore there's no scattering and tangling. Moreover a run-time library for querying and retrieving adapters is created. With this library the user can query adapters by using an instance, a type, an adapter name or a combination of these as a key. This allows accessing adapters in a flexible way, whereas in the traditional OO implementation, it is only possible to access an adapter is by using its instance name.  




%Software evolution requires integration of new components with the old ones. In an
%ideal component-based system, this integration should be seamless meaning 
 %the legacy components remain untouched and the interface of the new component is fully compatible with the existing interfaces. 
%Unfortunately such systems do not exist; as a result the integration is seldom
%seamless. Throughout the paper we will refer to the integration of two software components as a
%\emph{binding}. 
%
%We have defined three major challenges regarding binding. 
%\begin{enumerate}
  	%\item When components evolve, the links between them
	%must be re-established. 
 	 %\item When adding unforeseen functionality to a system, no explicit hooks
 	 %exist for attaching the new component. 
	%\item The interface of the components is not compatible and they should be adapted.
%\end{enumerate}
%
%Handling the first challenge requires a \emph{maintainable} way of expressing binding. It is possible to program binding according to some foreseeable evolution scenarios. However in today's component-based systems, third-party software is widely used. So when the interface offered by a third-party software changes, it is necessary to re-program the binding. \emph{Reusable binding structures} and expressing binding in a \emph{concise} manner is then valuable to reduce this programming effort.
%
%Handling the second challenge requires a means to expose certain information in an
%application's control flow and inject additional behavior to the control flow. Context exposure can be done via object-oriented programming(OOP), by providing classes which store and expose context information. Injecting additional behavior can be achieved via design patterns like dependency injection or decorator. However these methods are valid for planned extensions, and they will not be sufficient when a new component needs to access an unexposed context. Another issue is linked to the nature of binding two components. Since components need to be connected through possibly multiple points the \textbf{binding concern} becomes cross-cutting. It has been shown that OOP is not effective in modularizing such cross-cutting concerns.  
%
%Handling the third challenge requires a means to express the mapping between components. In this paper we present new language mechanisms to express such mappings and provide improvement on the solutions of the first two challenges. Our approach consists of two language concepts that work together; \emph{instance selectors} and \emph{adapter declarations}. 
%
%In the original GoF book, Adapter Pattern's purpose is defined as ``converting the interface of a class into another interface clients expect. Adapter lets classes work together that could not otherwise because of incompatible interfaces''. Adapters are an important part of a component-based system, since they are the building blocks of binding. 
%
%Our approach is designed as an addition to Aspect-Oriented Programming (AOP)\textbf{(?)}. AOP is used to modularize crosscutting
%concerns and with its 'weaving' mechanism, it is possible to change the behavior or the structure of an implementation without altering the
%implementation itself. These properties of AOP make it a desirable candidate for modularizing the binding concern.
%
%AOP is effective for achieving loose-coupling. It
%can capture information or inject behavior from a component without being
%acknowledged. AOP also facilitates the OO way of loose-coupling, which done via
%interfaces. It is possible to declare subtypes of an interface and provide the
%subsequent implementation in an aspect.  AOP is also efficient in localizing a concern. So when two components are bound using
%AOP, the binding implementation will be in one place. This is an important
%property for maintaining the modules providing loose-coupling. 
%
%\textcolor[rgb]{0.50,0.50,0.50}{A pointcut is a program construct that selects join points and expose context at
%those points \textbf{(AspectJ in Action book)}. Hence by using pointcuts we can
%define entry points to a system to inject new behavior. Of course this approach
%is limited with the expressiveness of the join-point model of the AO-language. }
%
%However implementation of adapters in current AOP approaches is type invasive. In AspectJ Adapter Pattern is implemented via inter-type declarations which alter the type system by making the adaptee implement a certain interface. This changes the type hierarchy of the adaptee. Also the Adapter Pattern disappears into the AspectJ syntax, which diminishes the visibility of the pattern. CaesarJ has an explicit syntax for defining adapters, which are referred to as wrappers in CaesarJ. However CeaserJ, although it gives great power over separation of concerns, tend to become too fragmented, hurting maintainability. 


\section{The Binding Language}

Instance pointcuts and adapter declarations are language concepts and ideally every aspect-oriented language can be extended to host them. We will discuss possible extentions in other well known AO-languages at the end of this section. 
We have implemented a prototype in AspectJ. While we have extended the syntax of AspectJ for instance pointcuts and adapter declarations, we have reused AspectJ's primitive pointcuts for the instance pointcut expression. 



\subsection{Instance Selectors / Pointcuts}
\subsection{Adapter Declarations}


\section{Comparative Evaluation}
This section will include an example and compare solutions in AspectBind, AspectJ and CaesarJ.



\section{Related Work}


\end{document}
